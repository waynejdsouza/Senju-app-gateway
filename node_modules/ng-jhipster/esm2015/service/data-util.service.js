/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 Copyright 2013-2019 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * An utility service for data.
 */
export class JhiDataUtils {
    constructor() {
    }
    /**
     * Method to abbreviate the text given
     * @param {?} text
     * @param {?=} append
     * @return {?}
     */
    abbreviate(text, append = '...') {
        if (text.length < 30) {
            return text;
        }
        return text ? (text.substring(0, 15) + append + text.slice(-10)) : '';
    }
    /**
     * Method to find the byte size of the string provides
     * @param {?} base64String
     * @return {?}
     */
    byteSize(base64String) {
        return this.formatAsBytes(this.size(base64String));
    }
    /**
     * Method to open file
     * @param {?} contentType
     * @param {?} data
     * @return {?}
     */
    openFile(contentType, data) {
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            // To support IE and Edge
            /** @type {?} */
            const byteCharacters = atob(data);
            /** @type {?} */
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            /** @type {?} */
            const byteArray = new Uint8Array(byteNumbers);
            /** @type {?} */
            const blob = new Blob([byteArray], {
                type: contentType
            });
            window.navigator.msSaveOrOpenBlob(blob);
        }
        else {
            // Other browsers
            /** @type {?} */
            const fileURL = `data:${contentType};base64,${data}`;
            /** @type {?} */
            const win = window.open();
            win.document.write('<iframe src="' + fileURL + '" frameborder="0" style="border:0; top:0; left:0; bottom:0; right:0; width:100%; height:100%;" allowfullscreen></iframe>');
        }
    }
    /**
     * Method to convert the file to base64
     * @param {?} file
     * @param {?} cb
     * @return {?}
     */
    toBase64(file, cb) {
        /** @type {?} */
        const fileReader = new FileReader();
        fileReader.onload = function (e) {
            /** @type {?} */
            const base64Data = e.target.result.substr(e.target.result.indexOf('base64,') + 'base64,'.length);
            cb(base64Data);
        };
        fileReader.readAsDataURL(file);
    }
    /**
     * Method to clear the input
     * @param {?} entity
     * @param {?} elementRef
     * @param {?} field
     * @param {?} fieldContentType
     * @param {?} idInput
     * @return {?}
     */
    clearInputImage(entity, elementRef, field, fieldContentType, idInput) {
        if (entity && field && fieldContentType) {
            if (entity.hasOwnProperty(field)) {
                entity[field] = null;
            }
            if (entity.hasOwnProperty(fieldContentType)) {
                entity[fieldContentType] = null;
            }
            if (elementRef && idInput && elementRef.nativeElement.querySelector('#' + idInput)) {
                elementRef.nativeElement.querySelector('#' + idInput).value = null;
            }
        }
    }
    /**
     * @private
     * @param {?} suffix
     * @param {?} str
     * @return {?}
     */
    endsWith(suffix, str) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    paddingSize(value) {
        if (this.endsWith('==', value)) {
            return 2;
        }
        if (this.endsWith('=', value)) {
            return 1;
        }
        return 0;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    size(value) {
        return value.length / 4 * 3 - this.paddingSize(value);
    }
    /**
     * @private
     * @param {?} size
     * @return {?}
     */
    formatAsBytes(size) {
        return size.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + ' bytes';
    }
    /**
     * Sets the base 64 data & file type of the 1st file on the event (event.target.files[0]) in the passed entity object
     * and returns a promise.
     *
     * @param {?} event the object containing the file (at event.target.files[0])
     * @param {?} entity the object to set the file's 'base 64 data' and 'file type' on
     * @param {?} field the field name to set the file's 'base 64 data' on
     * @param {?} isImage boolean representing if the file represented by the event is an image
     * @return {?} a promise that resolves to the modified entity if operation is successful, otherwise rejects with an error message
     */
    setFileData(event, entity, field, isImage) {
        return new Promise((resolve, reject) => {
            if (event && event.target && event.target.files && event.target.files[0]) {
                /** @type {?} */
                const file = event.target.files[0];
                if (isImage && !/^image\//.test(file.type)) {
                    reject(`File was expected to be an image but was found to be ${file.type}`);
                }
                else {
                    this.toBase64(file, (base64Data) => {
                        entity[field] = base64Data;
                        entity[`${field}ContentType`] = file.type;
                        resolve(entity);
                    });
                }
            }
            else {
                reject(`Base64 data was not set as file could not be extracted from passed parameter: ${event}`);
            }
        });
    }
    /**
     * Method to download file
     * @param {?} contentType
     * @param {?} data
     * @param {?} fileName
     * @return {?}
     */
    downloadFile(contentType, data, fileName) {
        /** @type {?} */
        const byteCharacters = atob(data);
        /** @type {?} */
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        /** @type {?} */
        const byteArray = new Uint8Array(byteNumbers);
        /** @type {?} */
        const blob = new Blob([byteArray], {
            type: contentType
        });
        /** @type {?} */
        const tempLink = document.createElement('a');
        tempLink.href = window.URL.createObjectURL(blob);
        tempLink.download = fileName;
        tempLink.target = '_blank';
        tempLink.click();
    }
}
JhiDataUtils.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
JhiDataUtils.ctorParameters = () => [];
/** @nocollapse */ JhiDataUtils.ngInjectableDef = i0.defineInjectable({ factory: function JhiDataUtils_Factory() { return new JhiDataUtils(); }, token: JhiDataUtils, providedIn: "root" });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1qaGlwc3Rlci8iLCJzb3VyY2VzIjpbInNlcnZpY2UvZGF0YS11dGlsLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7OztBQVF2RCxNQUFNLE9BQU8sWUFBWTtJQUVyQjtJQUNBLENBQUM7Ozs7Ozs7SUFLRCxVQUFVLENBQUMsSUFBWSxFQUFFLE1BQU0sR0FBRyxLQUFLO1FBRW5DLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7WUFDbEIsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUNELE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzFFLENBQUM7Ozs7OztJQUtELFFBQVEsQ0FBQyxZQUFvQjtRQUN6QixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7Ozs7Ozs7SUFLRCxRQUFRLENBQUMsV0FBbUIsRUFBRSxJQUFZO1FBQ3RDLElBQUksTUFBTSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFOzs7a0JBRWpELGNBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDOztrQkFDM0IsV0FBVyxHQUFHLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUM7WUFDcEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFF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Qzs7Y0FDM0IsV0FBVyxHQUFHLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUM7UUFDcEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7O2NBQ0ssU0FBUyxHQUFHLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQzs7Y0FDdkMsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDL0IsSUFBSSxFQUFFLFdBQVc7U0FDcEIsQ0FBQzs7Y0FDSSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUM7UUFDNUMsUUFBUSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqRCxRQUFRLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUM3QixRQUFRLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztRQUMzQixRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDckIsQ0FBQzs7O1lBckpKLFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQiIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gQ29weXJpZ2h0IDIwMTMtMjAxOSB0aGUgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgZnJvbSB0aGUgSkhpcHN0ZXIgcHJvamVjdC5cblxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBKSGlwc3RlciBwcm9qZWN0LCBzZWUgaHR0cHM6Ly93d3cuamhpcHN0ZXIudGVjaC9cbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIHV0aWxpdHkgc2VydmljZSBmb3IgZGF0YS5cbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBKaGlEYXRhVXRpbHMge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGFiYnJldmlhdGUgdGhlIHRleHQgZ2l2ZW5cbiAgICAgKi9cbiAgICBhYmJyZXZpYXRlKHRleHQ6IHN0cmluZywgYXBwZW5kID0gJy4uLicpIHtcblxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPCAzMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQgPyAodGV4dC5zdWJzdHJpbmcoMCwgMTUpICsgYXBwZW5kICsgdGV4dC5zbGljZSgtMTApKSA6ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBmaW5kIHRoZSBieXRlIHNpemUgb2YgdGhlIHN0cmluZyBwcm92aWRlc1xuICAgICAqL1xuICAgIGJ5dGVTaXplKGJhc2U2NFN0cmluZzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEFzQnl0ZXModGhpcy5zaXplKGJhc2U2NFN0cmluZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBvcGVuIGZpbGVcbiAgICAgKi9cbiAgICBvcGVuRmlsZShjb250ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG4gICAgICAgICAgICAvLyBUbyBzdXBwb3J0IElFIGFuZCBFZGdlXG4gICAgICAgICAgICBjb25zdCBieXRlQ2hhcmFjdGVycyA9IGF0b2IoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBieXRlTnVtYmVycyA9IG5ldyBBcnJheShieXRlQ2hhcmFjdGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVOdW1iZXJzW2ldID0gYnl0ZUNoYXJhY3RlcnMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnl0ZUFycmF5XSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyIGJyb3dzZXJzXG4gICAgICAgICAgICBjb25zdCBmaWxlVVJMID0gYGRhdGE6JHtjb250ZW50VHlwZX07YmFzZTY0LCR7ZGF0YX1gO1xuICAgICAgICAgICAgY29uc3Qgd2luID0gd2luZG93Lm9wZW4oKTtcbiAgICAgICAgICAgIHdpbi5kb2N1bWVudC53cml0ZShcbiAgICAgICAgICAgICAgICAnPGlmcmFtZSBzcmM9XCInICsgZmlsZVVSTCArICdcIiBmcmFtZWJvcmRlcj1cIjBcIiBzdHlsZT1cImJvcmRlcjowOyB0b3A6MDsgbGVmdDowOyBib3R0b206MDsgcmlnaHQ6MDsgd2lkdGg6MTAwJTsgaGVpZ2h0OjEwMCU7XCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGNvbnZlcnQgdGhlIGZpbGUgdG8gYmFzZTY0XG4gICAgICovXG4gICAgdG9CYXNlNjQoZmlsZTogRmlsZSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXI6IEZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGU6IGFueSkge1xuICAgICAgICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGUudGFyZ2V0LnJlc3VsdC5zdWJzdHIoZS50YXJnZXQucmVzdWx0LmluZGV4T2YoJ2Jhc2U2NCwnKSArICdiYXNlNjQsJy5sZW5ndGgpO1xuICAgICAgICAgICAgY2IoYmFzZTY0RGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gY2xlYXIgdGhlIGlucHV0XG4gICAgICovXG4gICAgY2xlYXJJbnB1dEltYWdlKGVudGl0eTogYW55LCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBmaWVsZDogc3RyaW5nLCBmaWVsZENvbnRlbnRUeXBlOiBzdHJpbmcsIGlkSW5wdXQ6IHN0cmluZykge1xuICAgICAgICBpZiAoZW50aXR5ICYmIGZpZWxkICYmIGZpZWxkQ29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5W2ZpZWxkXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5Lmhhc093blByb3BlcnR5KGZpZWxkQ29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5W2ZpZWxkQ29udGVudFR5cGVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50UmVmICYmIGlkSW5wdXQgJiYgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWRJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBpZElucHV0KS52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGVuZHNXaXRoKHN1ZmZpeDogc3RyaW5nLCBzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGFkZGluZ1NpemUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLmVuZHNXaXRoKCc9PScsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5kc1dpdGgoJz0nLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2l6ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAvIDQgKiAzIC0gdGhpcy5wYWRkaW5nU2l6ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb3JtYXRBc0J5dGVzKHNpemU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBzaXplLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJyAnKSArICcgYnl0ZXMnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJhc2UgNjQgZGF0YSAmIGZpbGUgdHlwZSBvZiB0aGUgMXN0IGZpbGUgb24gdGhlIGV2ZW50IChldmVudC50YXJnZXQuZmlsZXNbMF0pIGluIHRoZSBwYXNzZWQgZW50aXR5IG9iamVjdFxuICAgICAqIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGUgKGF0IGV2ZW50LnRhcmdldC5maWxlc1swXSlcbiAgICAgKiBAcGFyYW0gZW50aXR5IHRoZSBvYmplY3QgdG8gc2V0IHRoZSBmaWxlJ3MgJ2Jhc2UgNjQgZGF0YScgYW5kICdmaWxlIHR5cGUnIG9uXG4gICAgICogQHBhcmFtIGZpZWxkIHRoZSBmaWVsZCBuYW1lIHRvIHNldCB0aGUgZmlsZSdzICdiYXNlIDY0IGRhdGEnIG9uXG4gICAgICogQHBhcmFtIGlzSW1hZ2UgYm9vbGVhbiByZXByZXNlbnRpbmcgaWYgdGhlIGZpbGUgcmVwcmVzZW50ZWQgYnkgdGhlIGV2ZW50IGlzIGFuIGltYWdlXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG1vZGlmaWVkIGVudGl0eSBpZiBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIHJlamVjdHMgd2l0aCBhbiBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgc2V0RmlsZURhdGEoZXZlbnQsIGVudGl0eSwgZmllbGQ6IHN0cmluZywgaXNJbWFnZTogYm9vbGVhbik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5maWxlcyAmJiBldmVudC50YXJnZXQuZmlsZXNbMF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpc0ltYWdlICYmICEvXmltYWdlXFwvLy50ZXN0KGZpbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGBGaWxlIHdhcyBleHBlY3RlZCB0byBiZSBhbiBpbWFnZSBidXQgd2FzIGZvdW5kIHRvIGJlICR7ZmlsZS50eXBlfWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9CYXNlNjQoZmlsZSwgKGJhc2U2NERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eVtmaWVsZF0gPSBiYXNlNjREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5W2Ake2ZpZWxkfUNvbnRlbnRUeXBlYF0gPSBmaWxlLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGBCYXNlNjQgZGF0YSB3YXMgbm90IHNldCBhcyBmaWxlIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBwYXNzZWQgcGFyYW1ldGVyOiAke2V2ZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZG93bmxvYWQgZmlsZVxuICAgICAqL1xuICAgIGRvd25sb2FkRmlsZShjb250ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGRhdGEpO1xuICAgICAgICBjb25zdCBieXRlTnVtYmVycyA9IG5ldyBBcnJheShieXRlQ2hhcmFjdGVycy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IGJ5dGVDaGFyYWN0ZXJzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J5dGVBcnJheV0sIHtcbiAgICAgICAgICAgIHR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0ZW1wTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgdGVtcExpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB0ZW1wTGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICB0ZW1wTGluay50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgdGVtcExpbmsuY2xpY2soKTtcbiAgICB9XG59XG4iXX0=